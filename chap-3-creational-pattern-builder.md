```
빌더(Builder)

의도
복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여,
서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공할 수 있도록 합니다.
=> 구현을 분리해서 생성 절차 자체는 유지시킬 수 있음

동기
RTF(Rich Text Format) 문서 판독기는 RTF 포맷에서 다른 텍스트 포맷으로 변환 가능해야함
문서 판독기는 RTF 문서를 일반 위젯으로 변경가능해야하는데, 
문제는 가능한 문서 형식들 간의 변환(conversion) 가능성에 제한이 없으며,
판독기의 변경 없이도 새로운 형태의 변환이 추가될 수 있어야 합니다.
=> 판독기(RTFReader)와 클래스가 분리되어 상관없음
문서 형식들 간의 변환 가능성에 제한은 서브클래스로 구현될듯(Builder 클래스의 서브클래스를 작성해서 여러 포맷으로 변환가능해보임..)

이를 위해, TextConverter 객체와 RTFReader 클래스를 함께 함께 복합하는 방법이 필요
RTFReader는 RTF 토큰을 판독할때마다 TextConverter에 토큰을 변환하도록 요청하는 것
TextConverter 객체는 데이터 변환을 수행하거나 어떤 특별한 형태로 토큰을 표현할 책임가짐
=> 책임 분리

TextConverter의 서브클래스는 서로 다른 변환과 포맷을 처리할 수 있도록 갈라집니다.
=> 위의 문서 형식들 간의 변환 가능성에 제한이 없어야한다는 내용의 구현

각 변환기(converter) 클래스들은 복잡한 객체를 생성하고 조립하는데 필요한 매커니즘을 converter 클래스에
정의된 인터페이스의 각 연산에 구현합니다.
=> 모든 실제 구현은 converter 클래스에서 담당

한 변환기를 판독기와 분리시켜서, 판독기는 RTF 문서의 책임만 지게 하자는 것입니다.
빌더 패턴은 이런 문제를 푸는데 씁니다. 지금까지 등장한 각 변환기 클래스들이 바로 '빌더 패턴'에서 쓰는 용어인 '빌더'
그리고 판독기는 '디렉터(director)'라고 합니다.
=> 빌더와 디렉터 간의 관계

빌더 패턴은 문서 포맷을 해석하는 알고리즘을 
다른 형태로 어떻게 변환할 것인가를 결정하는 알고리즘과 분리해냅니다.

이 패턴을 쓰면 파싱 알고리즘은 서로 다른 문서 형식으로 변형하는 용도로 재사용될 수 있습니다.
=> 다른 변환 클래스(빌더)와 함께 사용되어 절차적으로 완성시킬 수 있음을 의미하는듯..
TextConverter의 서브클래스에 맞추어 RTFReader를 설정하기만 하면 끝납니다.

활용성
빌더 패턴은 다음의 경우에 사용
- 복합 객체의 생성 알고리즘이 이를 합성하는 요소 객체들이 무엇인지
이들의 조립 방법에 독립적일 때
=> RTFReader와 TextConverter의 분리와 같은 사례, 분리하고 RTFReader는 언제든지 다른 서브클래스와 복합해서 새로운 절차로 사용가능
- 합성할 객체들의 표현이 서로 다르더라도 생성 절차에서 이를 지원해야할 때
=> 서브클래스로 여러 객체들을 표현이 달라지고, 이 서브클래스와의 합성하는 사례 얘기같음

참여자
- Builder(TextConverter): Product 객체의 일부 요소들을 생성하기 위한 추상 인터페이스를 정의
- ConcreteBuilder(TextConverter의 서브클래스들): Builder 클래스에 정의된 인터페이스를 구현하며, 제품의 부품들을 모아 빌더를 복합합니다.
실제 생성한 요소의 표현을 정의하고 관리합니다. 또한 제품을 검색하는데 필요한 인터페이스를 제공합니다.
=> 마지막 말만 모르겠음
- Director(RTFReader): Builder 인터페이스를 사용하는 객체를 합성
- Product(TextWidget.. 실제 생성된 애들): 생성할 복합 객체를 표현합니다. ConcreteBuilder는 제품의 내부 표현을 구축하고
복합 객체가 어떻게 구성되는지에 관한 절차를 정의합니다.
=> 마지막 말 솔직히 모르겠음

협력 방법
- 사용자는 Director 객체를 생성하고, 이렇게 생성한 객체를 자신이 원하는 Builder 객체로 합성
- 제품의 일부가 구축(built)될 때마다 Director는 Builder에 통보
- Builder는 Director의 요청을 처리해 제품에 부품을 추가
- 사용자는 Builder에서 제품을 검색

결과
빌더 패턴을 사용 시 얻는 이익과 부담은 다음과 같다
1. 제품에 대한 내부 표현을 다양하게 변화할 수 있다.
=> 구현에 대해 완전 분리되어있어 유연성
2. 생성과 표현에 필요한 코드를 분리합니다.
=> 디렉터가 빌더에게 생성 요청만 하고 실제 구현은 전부 빌더에서 함
3. 복합 객체를 생성하는 절차를 좀 더 세밀하게 나눌수 있다.
=> 디렉터가 빌더에게 만든 전체 복합 객체를 되돌려받을 때까지 제품 복합의 과정은 계속 됨
그렇기에 빌더 클래스의 인터페이스에는 제품 생성하는 과정 자체가 반영됨
buildPart() 메서드를 통해 과정 확인 가능

구현
추상 클래스인 Builder 클래스에 디렉터가 요청하는 각각의 요소들을 생성하는 연산들을 정의
아무것도 구현되지 않은 단순한 인터페이스일 뿐
이 클래스를 상속하는 서브클래스 ConcreteBuilder가 자신에게 필요한 요소를 생성하도록
부모 클래스의 연산을 재정의
생각해봐야할 구현 이슈들은 이렇다.
1. 조합과 구축에 필요한 인터페이스를 정의
이미 구축된 제품의 부분에 대한 접근이 필요할수 있음
단순하게 요소를 추가하는 방식이 아닌, 기존의 제품들을 모아서 새로 만드는 상향식 복합
여러 개의 빌더에서 각자의 역할을 수행해서 디렉터에게 반환 필요
2. 제품에 대한 추상클래스는 필요없는가?
=> 필요없으면 안만들어도 된단 얘기같은데.. 솔직히 이해안됨
3. Builder에 있는 메서드에 대해서는 구현을 제공하지 않음

관련 패턴
복잡한 객체를 생성해야할 때 추상 팩토리 패턴은 빌더 패턴과 비슷한 모습을 보입니다.
근본적인 차이가 있다면 빌더 패턴은 복잡한 객체의 단계별 생성에 중점을 둔 반면
추상 팩토리 패턴은 제품의 유사성이 존재할 때 유연한 설계에 중점을 둔다
빌더 패턴은 생성의 마지막 단계에서 생성한 제품을 반환하는 반면, 
추상 팩토리 패턴은 만드는 즉시 제품을 반환
추상 팩토리 패턴은 만드는 제품을 꼭 모여야만 의미있는 것이 아니라
하나만으로도 의미가 있기 때문입니다.
=> 마지막 말 이해안감, 유사성을 두고 유연한 설계 중점이랬는데 모여야 의미있는게 아니라니..
절차에 대한 얘기를 하고싶은거 같은데 주어 목적어가 없음..
```
